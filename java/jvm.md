# JVM

 When we compile a _.java_ file, _.class_ files\(contains byte-code\) with the same class names present in _.java_ file are generated by the Java compiler. This _.class_ file goes into various steps when we run it. These steps together describe the whole JVM.

![](../.gitbook/assets/image%20%286%29.png)

## **Class Loader Subsystem** 

It is mainly responsible for three activities.

* Loading
* Linking
* Initialization

 **Loading :** The Class loader reads the _.class_ file, generate the corresponding binary data and save it in method area. For each _.class_ file, JVM stores following information in method area.

 **Linking :** Performs verification, preparation, and \(optionally\) resolution.

 **Initialization :** In this phase, all static variables are assigned with their values defined in the code and static block\(if any\). This is executed from top to bottom in a class and from parent to child in class hierarchy.

![](../.gitbook/assets/image%20%287%29.png)

##  **JVM Memory**

 **Method area :**In method area, all class level information like class name, immediate parent class name, methods and variables information etc. are stored, including static variables. There is only one method area per JVM, and it is a shared resource.

 **Heap area :**Information of all objects is stored in heap area. There is also one Heap Area per JVM. It is also a shared resource.

 **Stack area :**For every thread, JVM create one run-time stack which is stored here. Every block of this stack is called activation record/stack frame which store methods calls. All local variables of that method are stored in their corresponding frame. After a thread terminate, itâ€™s run-time stack will be destroyed by JVM. It is not a shared resource.

**PC Registers :**Store address of current execution instruction of a thread. Obviously each thread has separate PC Registers.

**Native method stacks :**For every thread, separate native stack is created. It stores native method information.

## **Execution Engine**

Execution engine execute the _.class_ \(bytecode\). It reads the byte-code line by line, use data and information present in various memory area and execute instructions. It can be classified in three parts :-

* _Interpreter_ : It interprets the bytecode line by line and then executes. The disadvantage here is that when one method is called multiple times, every time interpretation is required.
* _Just-In-Time Compiler\(JIT\)_ : It is used to increase efficiency of interpreter.It compiles the entire bytecode and changes it to native code so whenever interpreter see repeated method calls,JIT provide direct native code for that part so re-interpretation is not required,thus efficiency is improved.
* _Garbage Collector_ : It destroy un-referenced objects.For more on Garbage Collector,refer [Garbage Collector](https://www.geeksforgeeks.org/garbage-collection-java/).

## **Java Native Interface \(JNI\) :** 

It is a interface which interacts with the Native Method Libraries and provides the native libraries\(C, C++\) required for the execution. It enables JVM to call C/C++ libraries and to be called by C/C++ libraries which may be specific to hardware.

## **Native Method Libraries :** 

It is a collection of the Native Libraries\(C, C++\) which are required by the Execution Engine.

